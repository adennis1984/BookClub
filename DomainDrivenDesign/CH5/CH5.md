# CH5. 軟體中所表示的模型

## Objective (客觀事實)

* ENTITY：某種具有連續性（continuity）和標識（identity）的事物
* VALUE OBJECT：描述某種狀態的屬性（attribute）
* SERVICE：
  > 領域中有一些方面適合用動作（action）或操作（operation）來表示
  > SERVICE 是應客戶端的請求來完成某事
  > 當對『軟體要做的某項無狀態的活動』進行建模時，就可以將該活動作為一項 SERVICE

### 關聯

* 模型中每一個可遍歷（traversable）的關聯，軟體中都要有同樣屬性的機制
* 至少有三種方法可以讓關聯更易於控制：
  > 規定一個遍歷方向
  > 增加一個限定符（qualifier），以便有效地減少多重關聯
  > 消除不必要的關聯

![Fig 5.2](./203769.jpg?raw=true "Fig 5.2")

* Fig 5.2 被約束的關聯可以傳達更多的知識，而且是更實用的設計。

* 堅持將關聯限定為領域所傾向的方向，不僅可以提高這些關聯的表達能力，還能簡化其實作，更可以突顯『剩下的雙向關聯的重要性』。當雙向關聯是領域的一個語意特徵（semantic characteristic）時，或者當應用程式的功能要求雙向關聯時，就需要保留它，以便表達出這些需求

### 模式：ENTITY（又稱為 REFERENCE OBJECT）

* 很多物件不是透過它們的屬性定義的，而是透過連續性和標識（identity）定義的
* 物件建模有可能把我們的注意力引到物件的屬性上，但實體的基本概念是一種貫穿整個生命週期（甚至會經歷多種形式）的抽象的連續性
* 一些物件些主要不是由它們的屬性定義的。它們實際上表示了一條標識線(athread of identity)，這條線跨越時間,而且常常經歷多種不同的表示（representation）。有時，這樣的物件必須與另一個具有不同屬性的物件相匹配。而有時一個物件必須與具有相同屬性的另一個物件區隔。錯誤的標識可能會破壞資料。
* ENTITY（實體）有特殊的建模和設計思路。他們具有生命週期，這期間它們的形式和內容可能發生根本改變，但必頌保持一種內在的連續性。為了有效地追蹤這些物件，必須定義他們的標識。他們的類別定義、職責、屬性和關聯必須由其「標識」來決定,而不依賴其所具有的「屬性」。
* 即使對於那些生根本變化或者生命週期不太複雜的 ENTITY。也應該在語意上把他們作為ENTITY 對待,這樣可以得到更清晰的模型和更健壯的實作。
* ENTITY 可以是任何事物，只要滿足兩個條件即可：
  > * 一是它在整個生命週期中具有連續性
  > * 二是它的區別並不是由那些「對使用者非常重要的屬性」決定的
* 在定義標識操作時，要確保這種操作為每個物件產生唯一的結果，這可以透過附加一個保證唯一性的符號（symbol）來實作。這種定義標識的方法可能來自外部，也可能是由系統建立的任意識別子，但它在模型中必須是唯一的標識。
  > 模型必須定義出『符合什麼條件才算是相同的事物』。

### 模式：VALUE OBJECT

* 很多物件沒有概念上的標識（conceptual identity），它們描述了一個事物的某種特徵
  
* VALUE OBJECT 被實例化之後用來表示一些設計元素，對於這些設計元素，我們只關心它們是什麼（WHAT），而不關心它們是誰（WHO or WHICH）
* 當我們只關心一個模型元素的屬性時，應把他歸類為 Value Object。我們應該使用這個模型元素能夠表示出其屬性的『意義』，並為它提供相關功能。Value Object 應該是不可變的。不要為它分配任何標識，而且不要把它設計成像 Entity 那麼複雜。

* VALUE 的改變可能會破壞所有者的約束條件。這個問題可以透過傳遞一個不變的物件或傳遞一個副本來解決。

* 以下幾種情況最好使用共享，這樣可以發揮共享的最大價值並最大限度地減少麻煩：
  > * 節省資料庫空間或減少物件數量是一個關鍵要求時
  > * 通訊開銷很低時（ex. 在中央伺服器之中）
  > * 共享的物件被嚴格限定為不可變時
* 『儲存相同資料的多個副本的技術』被稱為 `非規範化` (or `非正規化`, denormalization)，當『存取時間』比『儲存空間』或『維護的簡單性』更重要時，通常使用這種技術。

## Reflective (主觀感受)

* Entity：本身會隨著時間的更迭是可變的，但需有一個不可變的 identifier (識別子)
* Value Object：只關心這物件的屬性資訊，本身應為不可變（immutable）
  
## Interpretive (有何啟發)

* 透過約束（constrain）可降低複雜度（降維?）好像還不錯，但具體如何實作得到好處還沒什麼想法

## Decisional (具體實踐)

* 
  